%% -*- coding: utf-8 -*-

-module(apl).
-export([init/0, command/1, statement/1]).

% functions defined in erlang_APL_nif.c
%
-export([ command_utf8/1,     command_ucs/1,
          statement_utf8/1,   statement_ucs/1,
          fix_function_ucs/1, set_variable/3,
          eval_AB/3,
          eval_B/2,
          e2c/1,
          e2a/1
          ]).

init() -> erlang:load_nif("@prefix@/lib/@PACKAGE@/erlang_APL_nif", 0).

% dummy implementations for the functions defined in erlang_APL_nif.c...
%
command_utf8(_UTF8_string)       -> exit(command_utf8__not_loaded).
command_ucs(_)         -> exit(command_ucs__not_loaded).
statement_utf8(_UTF8_string)     -> exit(statement_utf8__not_loaded).
statement_ucs(_)       -> exit(statement_ucs__not_loaded).
fix_function_ucs(_UCS_string)    -> exit(fix_function_ucs__not_loaded).
set_variable(_UCS,_Shape,_Ravel) -> exit(set_variable___not_loaded).
eval_AB(_A, _Fun, _B)            -> exit(eval_AB__not_loaded).
eval_B(_Fun, _B)                 -> exit(eval_B__not_loaded).

% convert Erlang term X to a APL value cell
%
e2c(false)               -> 0;       % false == 0
e2c(true)                -> 1;       % true  == 1
e2c(X) when is_number(X) -> X;       % numeric scalar
e2c(X) when is_list(X) ->            % nested value
   {value, [length(X)], X};
e2c(X) -> X.

% convert Erlang term X to a APL value triple
%
%
e2a(false)               -> {value, [], [0]};            % false == 0
e2a(true)                -> {value, [], [1]};            % true  == 1
e2a(X) when is_number(X) -> {value, [], [X]};            % numeric scalar
e2a(X) when is_list(X) ->                                % vector
   Fun = fun(T, Acc) -> [e2c(T)|Acc] end,
   {value, [length(X)], lists:reverse(lists:foldl(Fun, [], X))};
e2a(X) -> {error, e2a, 'Invalid eterm', X}.

command(C)   -> command_ucs(C).
statement(S) -> statement_ucs(S).

